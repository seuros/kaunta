package main

import (
	"fmt"
	"os"
	"strconv"
	"strings"
)

// scans a migrations directory and writes a Go source file that exposes the
// highest *.up.sql version as a build-time constant.
// Just learned this, a better pattern might exist.
func main() {
	migrationsDir := "./migrations"
	outFile := "migration_version.gen.go"

	if len(os.Args) > 1 {
		migrationsDir = os.Args[1]
	}
	if len(os.Args) > 2 {
		outFile = os.Args[2]
	}

	maxVersion, err := findLatestVersion(migrationsDir)
	if err != nil {
		fatal(err)
	}

	if err := writeVersionFile(outFile, maxVersion); err != nil {
		fatal(err)
	}

	fmt.Printf("wrote %s with LatestMigrationVersion=%d\n", outFile, maxVersion)
}

func findLatestVersion(dir string) (int, error) {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return 0, fmt.Errorf("failed to read migrations dir %s: %w", dir, err)
	}

	max := 0
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}

		name := entry.Name()
		if !strings.HasSuffix(name, ".up.sql") {
			continue
		}

		prefix := strings.SplitN(name, "_", 2)[0]
		v, err := strconv.Atoi(prefix)
		if err != nil {
			return 0, fmt.Errorf("invalid migration filename %q: %w", name, err)
		}

		if v > max {
			max = v
		}
	}

	if max == 0 {
		return 0, fmt.Errorf("no *.up.sql migrations found in %s", dir)
	}

	return max, nil
}

func writeVersionFile(path string, version int) error {
	content := fmt.Sprintf(`// Code generated by go generate; DO NOT EDIT.
// Source: internal/database/tools/genmigrationversion

package database

const LatestMigrationVersion uint = %d
`, version)

	if err := os.WriteFile(path, []byte(content), 0o644); err != nil {
		return fmt.Errorf("failed to write %s: %w", path, err)
	}

	// keep the generated file formatted (avoid extra gofmt step)
	return nil
}

func fatal(err error) {
	fmt.Fprintln(os.Stderr, err)
	os.Exit(1)
}
